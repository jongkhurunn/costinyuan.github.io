<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Matlab基础</title>
    <url>/2022/10/04/Matlab%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Towards Better Understanding the Clothing Fashion Styles</title>
    <url>/2021/09/23/Towards-Better-Understanding/</url>
    <content><![CDATA[<h1 id="About"><a href="#About" class="headerlink" title="About"></a>About</h1><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Towards Better Understanding the Clothing Fashion Styles: A Multimodal Deep Learning Approach</p>
<p>争取更好地理解服装的时尚风格：一个多模态深度学习的方法</p>
<h3 id="发表时间期刊"><a href="#发表时间期刊" class="headerlink" title="发表时间期刊"></a>发表时间期刊</h3><p>2017年 AAAI</p>
<h3 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h3><p>Yihui Ma：清华大学计算机科学与技术系</p>
<p><a href="http://hcsi.cs.tsinghua.edu.cn/jiajiaabout">Jia Jia</a>*：清华大学计算机科学与技术系博士生导师、副教授</p>
<p>Suping Zhou：北京邮电大学</p>
<p>Jingtian Fu：清华大学计算机科学与技术系，清华大学美术学院</p>
<p>Yejun Liu：清华大学计算机科学与技术学院，清华大学美术学院</p>
<p>Zijian Tong：搜狗公司</p>
<h3 id="实验室"><a href="#实验室" class="headerlink" title="实验室"></a>实验室</h3><p>清华大学信息科学与技术国家实验室（TNList）<em>Key Laboratory of Pervasive Computing</em></p>
<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>视觉特征：领口形状、裤子长度、颜色主题等</p>
<p>服装风格：浪漫、优雅、经典等</p>
<p><strong>服装时尚风格在很大程度上得益于视觉细节，如何弥合两者的差距？</strong></p>
<h3 id="过去的研究"><a href="#过去的研究" class="headerlink" title="过去的研究"></a>过去的研究</h3><ul>
<li><p>解析服装纹理属性（2014）</p>
</li>
<li><p>建议综合应用系统来共同解析一组服装图像（2015）</p>
</li>
<li><p>专注于面向场景的服装推荐（2012）</p>
</li>
<li><p>欣赏上身男装的审美效果（2016）：<em>不具有普遍性，忽略了上下搭配的影响</em></p>
</li>
</ul>
<h3 id="两个挑战及解决办法"><a href="#两个挑战及解决办法" class="headerlink" title="两个挑战及解决办法"></a>两个挑战及解决办法</h3><p>Q1：如何定量描述各种服装的时尚风格？</p>
<p>A1：建立基于小林美学理论的时尚语义空间（FSS）来定量描述服装风格</p>
<blockquote>
<p>什么是FSS?</p>
<p>它是一个二维图像尺度的空间（warm-cool and soft-hard），包含购物网站上的数百个词。基于FSS不仅可以对时尚搭配进行定量评估，还可以直观地分析时尚潮流的动态变化。</p>
</blockquote>
<p>Q2：如何建立视觉特征和时尚风格之间的微妙关系（特别是服装搭配）？</p>
<p>A2：提出了一个基于时尚的多模态深度学习模型–双模态相关深度自动编码器（BCDA）来捕捉服装搭配中的相关性，与回归相连接，以实现将视觉特征映射到FSS的任务</p>
<blockquote>
<p>该BCDA有什么特点？</p>
<p>将<strong>上衣和下装</strong>看作服装搭配的两个模态，利用多模态深度学习的共享表述来学习模态之间的关系。此外，通过将服装类别（西装、大衣、紧身裤等）作为相关标签改进特征学习过程</p>
</blockquote>
<h3 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h3><h4 id="1-建立时尚语义空间FSS"><a href="#1-建立时尚语义空间FSS" class="headerlink" title="1. 建立时尚语义空间FSS"></a>1. 建立时尚语义空间FSS</h4><p>0）语义空间是小林在1995年提出的一个针对艺术设计的概念，将180个关键词放在划分为16个审美类别的尺度空间坐标中。</p>
<p>1）将亚马逊网站上近三年的服装类的评论中的词语划分出来</p>
<p>2）使用WordNet（1995），重训练形容词</p>
<p>3）人工移除不常用的形容词（比如 happy、sad），获得527个形容服装风格的词汇</p>
<p>4）使用WordNet::Similarity（2004）计算关键词与美学词的语义距离，选择三个距离最短的关键词，它们的加权算术平均值可以被视为坐标值</p>
<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20210928135259510.png" alt="image-20210928135259510" style="zoom:50%;" />

<h4 id="2-建立双模态相关深度自动编码器"><a href="#2-建立双模态相关深度自动编码器" class="headerlink" title="2. 建立双模态相关深度自动编码器"></a>2. 建立双模态相关深度自动编码器</h4><p>0）传统的深度自动编码器是一种特征学习的方式，但无法用来发现上装和下装的内在关系。</p>
<p>1）改造双模态深度自动编码器（2011）用于服装的特征学习，将上下衣特征作为两个模态输入，通过中间隐藏层的编码网络和解码网络，输出共享的表征（middle layer）</p>
<blockquote>
<p>相邻两层之间的关系取决于模型参数。训练结束后，我们确定参数并学习中间表征作为该步骤的输出。</p>
</blockquote>
<p>2）由于时尚风格受服装类别影响大（2016 具有相似视觉特征的服饰是不同的类别，比如西装和大衣），所以将服装类别标签引入到原始的对称结构中（黄色部分），使用神经网络重新获得相关标签c，同时重建特征x（体现在cost function代价函数中）</p>
<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20210928142913985.png" alt="image-20210928142913985" style="zoom:50%;" />

<h4 id="3-训练BCDA"><a href="#3-训练BCDA" class="headerlink" title="3. 训练BCDA"></a>3. 训练BCDA</h4><p>为了捕捉服装搭配中顶部和底部的内部相关性，我们通过预处理数据集来影响BCDA的训练过程：</p>
<p>将数据集特征（通过CNN模型 2015）分成三份，一份完整，一份去掉下装特征，一个去掉上衣特征，训练编码器，直到获得三个完整的数据集。如此BCDA就学会了自动服装搭配的潜在规则</p>
<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20211005171604531.png" alt="image-20211005171604531" style="zoom:50%;" />

<blockquote>
<p>在监督训练期间，算法只提供一种模式（如音频）的数据，然后只在另一种模式（如视频）上测试</p>
<p>Ngiam, J.; Khosla, A.; Kim, M.; Nam, J.; Lee, H.; and Ng, A. Y. 2011. Multimodal deep learning. In International Conference on Machine Learning, ICML 2011,</p>
</blockquote>
<h4 id="4-回归模型"><a href="#4-回归模型" class="headerlink" title="4. 回归模型"></a>4. 回归模型</h4><p>在FSS的527个风格词 Y(wc, hs) 中选择一个与BCDA输出特征 h^[Hh&#x2F;2] 的欧氏距离最短的词作为输入图像的时尚风格标签</p>
<h3 id="实验结果和分析"><a href="#实验结果和分析" class="headerlink" title="实验结果和分析"></a>实验结果和分析</h3><blockquote>
<p> 验证标准：计算了预测的坐标值和注释的坐标值之间的误差。误差用平均平方误差（MSE）来衡量。所有的实验都是在5个文件夹的交叉验证下进行</p>
</blockquote>
<h4 id="1-模型表现"><a href="#1-模型表现" class="headerlink" title="1. 模型表现"></a>1. 模型表现</h4><p>1）与其他自动编码器比较（回归模型都用SVM）</p>
<p>2）与其他回归模型比较（自动编码器都用BCDA）</p>
<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20210928155702148.png" alt="image-20210928155702148" style="zoom:50%;" />

<h4 id="2-特征贡献分析"><a href="#2-特征贡献分析" class="headerlink" title="2. 特征贡献分析"></a>2. 特征贡献分析</h4><p>1）上衣特征贡献大于衣</p>
<p>2）图案特征贡献大于颜色</p>
<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20210928160051011.png" alt="image-20210928160051011" style="zoom:50%;" />

<h4 id="3-参数敏感分析"><a href="#3-参数敏感分析" class="headerlink" title="3. 参数敏感分析"></a>3. 参数敏感分析</h4><p>1）训练数据规模：规模越大效果越好，但超过25000几乎收敛</p>
<p>2）隐藏层数量（理论上BCDA的描述能力可以通过更多层提高）：层数少于5时，性能会提高，层数过多性能会变差</p>
<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20210928160415779.png" alt="image-20210928160415779" style="zoom:50%;" />

<h3 id="实例论证"><a href="#实例论证" class="headerlink" title="实例论证"></a>实例论证</h3><h4 id="1-不同品牌的时尚风格分布"><a href="#1-不同品牌的时尚风格分布" class="headerlink" title="1. 不同品牌的时尚风格分布"></a>1. 不同品牌的时尚风格分布</h4><p>Missoni - 华丽；Libertine - 古典；6379 - 自然；Brunello Cucinelli - 别致</p>
<p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20210928160723621.png" alt="image-20210928160723621"></p>
<h4 id="2-同一品牌不同年分风格对比"><a href="#2-同一品牌不同年分风格对比" class="headerlink" title="2. 同一品牌不同年分风格对比"></a>2. 同一品牌不同年分风格对比</h4><p>著名品牌的时尚趋势一直是时尚人士关注的热点，分析Givenchy在过去11年的风格变化，2005年稳重–2010年精致–2015年线条感强</p>
<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20210928161803077.png" alt="image-20210928161803077" style="zoom:50%;" />

<h4 id="3-挖掘搭配规则"><a href="#3-挖掘搭配规则" class="headerlink" title="3. 挖掘搭配规则"></a>3. 挖掘搭配规则</h4><p>上衣领和下装的共同发生矩阵，每一列总和都是1，可以观察到：</p>
<p>1.直筒裤几乎适合所有领型的上衣 </p>
<p>2.虽然直筒裤和各种领子都很配，但紧身裤相配的毛皮&#x2F;高跟&#x2F;圆领&#x2F;巴托也是不错的选择此外，紧身裤-宽浅领口比直筒裤-宽浅领口的有更高的概率。因此，Bateau-tight也是时装秀中的一个经典搭配。</p>
<p>根据此发现，使用本模型建立了一个叫Magic Mirror（2016）的应用程序，可以帮助人们分析服装时尚风格</p>
<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20210928161752068.png" alt="image-20210928161752068" style="zoom:50%;" />

<h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ol>
<li><p>一个服装时尚数据集（开放），包含10年《vogue》杂志的32133张男女全身时装秀图片，并有完整的视觉特征（颜色、图案、服装种类）和时尚风格标签（10男10女从FSS中选词 颗粒度0.001 每张照片的每个属性都有3个不同标注者标注然后平均）</p>
<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20210928154648659.png" alt="image-20210928154648659" style="zoom:50%;" />
</li>
<li><p>建立一个通用的时尚语义空间来定量描述服装风格。它是一个二维图像尺度的空间，包含购物网站上的数百个词。基于FSS不仅可以对时尚搭配进行定量评估，还可以直观地分析时尚潮流的动态变化。</p>
</li>
<li><p>提出了一个基于时尚的多模态深度学习模型–双模态相关深度自动编码器（BCDA），与回归相连接，以实现将视觉特征映射到FSS的任务。具体来说，利用多模态策略学到的共享表征，BCDA可以充分利用上衣和下装之间的内部关联，并解决服装搭配的问题。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>fashion analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp函数编程</title>
    <url>/2022/07/30/cpp%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="转换函数conversion-function"><a href="#转换函数conversion-function" class="headerlink" title="转换函数conversion function"></a>转换函数conversion function</h2><p>没有返回类型的函数</p>
<p><code>operator type() const;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den=<span class="number">1</span>)</span><br><span class="line">    : <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)(m_numerator / m_denominator);  <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_numerator;  <span class="comment">// 分子</span></span><br><span class="line">  <span class="type">int</span> m_denominator;  <span class="comment">//分母</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h2><p>two parameters, one argument</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den=<span class="number">1</span>)</span><br><span class="line">    : <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den) &#123;&#125;</span><br><span class="line">  Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_numerator;  <span class="comment">// 分子</span></span><br><span class="line">  <span class="type">int</span> m_denominator;  <span class="comment">//分母</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">Fraction d2=f+<span class="number">4</span>;  <span class="comment">// 调用non-explicit ctor将4转化为Fraction，然后调用operator+</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>double()```和```operator+```同时存在会报错ambiguous</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### explicit-one-argument ctor</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class Fraction</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  explict Fraction(int num, int den=1)  //</span><br><span class="line">    : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">  operator double() const &#123;</span><br><span class="line">    return (double)(m_numerator / m_denominator);</span><br><span class="line">  &#125;</span><br><span class="line">  Fraction operator+(const Fraction&amp; f) &#123;</span><br><span class="line">    return Fraction(...);</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  int m_numerator;  // 分子</span><br><span class="line">  int m_denominator;  //分母</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fraction f(3,5);</span><br><span class="line">Fraction d2=f+4;  // [Error] conversion from &#x27;double&#x27; to &#x27;Fraction&#x27; require</span><br></pre></td></tr></table></figure>

<h2 id="pointer-like-classes"><a href="#pointer-like-classes" class="headerlink" title="pointer-like classes"></a>pointer-like classes</h2><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220725003539466.png" alt="image-20220725003539466"></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220725004621084.png" alt="image-20220725004621084"></p>
<h2 id="function-like-classes仿函数"><a href="#function-like-classes仿函数" class="headerlink" title="function-like classes仿函数"></a>function-like classes仿函数</h2><p>特点：重载 <code>()</code> 符号</p>
<p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220728153843824.png" alt="image-20220728153843824"></p>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220728155934104.png" alt="image-20220728155934104"></p>
<h3 id="function-template-函数模版"><a href="#function-template-函数模版" class="headerlink" title="function template 函数模版"></a>function template 函数模版</h3><p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220728161443024.png" alt="image-20220728161443024"></p>
<h3 id="member-template-成员模版"><a href="#member-template-成员模版" class="headerlink" title="member template 成员模版"></a>member template 成员模版</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">  <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">  </span><br><span class="line">  T1 first;</span><br><span class="line">  T2 second;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">pair</span>()</span><br><span class="line">    : <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a, <span class="type">const</span> T2&amp; b)</span><br><span class="line">    :<span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">  <span class="built_in">pair</span>(<span class="type">const</span> pair&lt;U1, U2&gt;&amp; p)</span><br><span class="line">    : <span class="built_in">first</span>(p.first), <span class="built_in">second</span>(p.second) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用在继承类中，U1::T1 &amp;&amp; U2::T2</p>
<h4 id="智能指针-shared-pointer"><a href="#智能指针-shared-pointer" class="headerlink" title="智能指针 shared pointer"></a>智能指针 shared pointer</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span>:public__shared_ptr&lt;_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Tp1* __p)</span></span></span><br><span class="line"><span class="function">    :__shared_ptr&lt;_Tp&gt;(__p)&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Basel* ptr = <span class="keyword">new</span> Derived1;  <span class="comment">// up-cast</span></span><br><span class="line"><span class="function">shared_ptr&lt;Basel&gt; <span class="title">sptr</span><span class="params">(<span class="keyword">new</span> Derived1)</span></span>;  <span class="comment">// 模拟up-cast</span></span><br></pre></td></tr></table></figure>

<h2 id="specialization-模版特化"><a href="#specialization-模版特化" class="headerlink" title="specialization 模版特化"></a>specialization 模版特化</h2><p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220729174109108.png" alt="image-20220729174109108"></p>
<blockquote>
<p>泛化</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="partial-specialization-偏特化"><a href="#partial-specialization-偏特化" class="headerlink" title="partial specialization 偏特化"></a>partial specialization 偏特化</h3><h4 id="个数的偏"><a href="#个数的偏" class="headerlink" title="个数的偏"></a>个数的偏</h4><p>确定了部分参数类型，如T需要是BOOLEAN类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line"><span class="keyword">class</span> vector&lt;<span class="type">bool</span>, Alloc&gt;</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="范围的偏"><a href="#范围的偏" class="headerlink" title="范围的偏"></a>范围的偏</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;U*&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">C&lt;string*&gt; obj;  <span class="comment">// 需要是指针</span></span><br></pre></td></tr></table></figure>

<h3 id="template-template-parameter-模版模版参数"><a href="#template-template-parameter-模版模版参数" class="headerlink" title="template template parameter 模版模版参数"></a>template template parameter 模版模版参数</h3><p>指定任意的容器？ </p>
<p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220729175358849.png" alt="image-20220729175358849"></p>
<p>修改为只能指针后可以使用第一参数作class的T</p>
<p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220729180403979.png" alt="image-20220729180403979"></p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>侯捷</tag>
      </tags>
  </entry>
  <entry>
    <title>c++面向对象-1-complex类</title>
    <url>/2022/07/21/cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1/</url>
    <content><![CDATA[<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream.h&gt;   标准库</span><br><span class="line">#include &quot;complex.h&quot;    自定义头文件</span><br></pre></td></tr></table></figure>

<ul>
<li>拓展名可以是.h .hpp 或者没有</li>
</ul>
<h4 id="防卫式声明-amp-头文件布局"><a href="#防卫式声明-amp-头文件布局" class="headerlink" title="防卫式声明 &amp; 头文件布局"></a>防卫式声明 &amp; 头文件布局</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.前置声明</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ostream</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>;</span><br><span class="line"></span><br><span class="line">complex&amp;</span><br><span class="line">	__doapl (complex* ths, <span class="type">const</span> complex&amp; r);</span><br><span class="line"><span class="comment">// 1.类-声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">complex</span> (<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>)</span><br><span class="line">     : <span class="built_in">re</span> (r), <span class="built_in">im</span> (i)</span><br><span class="line">  &#123; &#125;</span><br><span class="line">  complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex&amp;) ;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> re, im;</span><br><span class="line">  <span class="keyword">friend</span> complex&amp; __doapl (complex*, <span class="type">const</span> complex&amp;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.类-定义</span></span><br><span class="line">complex::function ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a>inline函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span></span></span><br><span class="line"><span class="function"><span class="title">imag</span><span class="params">(<span class="type">const</span> complex&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="built_in">imag</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public:</span><br><span class="line">	外界使用的函数</span><br><span class="line">	</span><br><span class="line">private:  </span><br><span class="line">	封装数据</span><br></pre></td></tr></table></figure>

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">complex</span> (<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>)</span><br><span class="line">    : <span class="built_in">re</span> (r), <span class="built_in">im</span> (i)</span><br><span class="line">  &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数名称一定要和类名称相同</li>
<li>构造函数可以重载但是要避免冲突，如</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">complex</span> () : <span class="built_in">re</span>(<span class="number">0</span>), <span class="built_in">im</span>(<span class="number">0</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">real</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123; re = r; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h4><p>不改变数据内容的函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果不加const的话 无法使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>自由取得friend的private成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> re, im;</span><br><span class="line">  <span class="keyword">friend</span> complex&amp; __doapl (complex*, <span class="type">const</span> complex&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">__doapl (complex* ths, <span class="type">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">  ths-&gt;re += r.re;</span><br><span class="line">  ths-&gt;im += r.im;</span><br><span class="line">  <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>相同class的各种objects互为friends</li>
</ul>
<h4 id="操作符重载（成员函数）"><a href="#操作符重载（成员函数）" class="headerlink" title="操作符重载（成员函数）"></a>操作符重载（成员函数）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex&amp;) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="type">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c3 += c2 += c1;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>重载的返回值设置成 complex&amp; 类型而不是 void， 是考虑到连加的情况</p>
</li>
<li><p>不是函数内的local变量就要加&amp;</p>
</li>
<li><p>操作符重载只能写一个</p>
</li>
</ul>
<h4 id="操作符重载（非成员函数）"><a href="#操作符重载（非成员函数）" class="headerlink" title="操作符重载（非成员函数）"></a>操作符重载（非成员函数）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span> (x) + <span class="built_in">real</span> (y),</span><br><span class="line">                  <span class="built_in">imag</span> (x) + <span class="built_in">imag</span> (y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不可以return by reference，因为返回的是一个local object</p>
</li>
<li><p>临时对象 typename ( ) 的用法，生命周期到函数结束</p>
</li>
<li><p>&lt;&lt; 必须写作非成员函数</p>
<ul>
<li>连续输出所以返回类型要设置成 ostream&amp;</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line">ostream&amp;</span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> complex&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="built_in">real</span> (x) &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; <span class="built_in">imag</span> (x) &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结注意"><a href="#总结注意" class="headerlink" title="总结注意"></a>总结注意</h4><ol>
<li>数据一定放在private</li>
<li>参数尽可能以reference传</li>
<li>返回值尽可能用reference传</li>
<li>类的body中应该加const就要加</li>
<li>构造函数的initialization list</li>
</ol>
<p><strong>不改变就用const</strong></p>
<p><strong>连用函数返回值不用void</strong></p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>侯捷</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>c++面向对象-2-String类</title>
    <url>/2022/07/21/cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2/</url>
    <content><![CDATA[<h4 id="防卫式写法模版"><a href="#防卫式写法模版" class="headerlink" title="防卫式写法模版"></a>防卫式写法模版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSTRING__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSTRING__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* cstr = <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> String&amp; str);</span><br><span class="line">  String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str);</span><br><span class="line">  ~<span class="built_in">String</span>();</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">function</span>(...) ...</span><br><span class="line"></span><br><span class="line">Global-<span class="built_in">function</span>(...) ...</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数-amp-析构函数"><a href="#构造函数-amp-析构函数" class="headerlink" title="构造函数 &amp; 析构函数"></a>构造函数 &amp; 析构函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* cstr = <span class="number">0</span>);</span><br><span class="line">  ~<span class="built_in">String</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="title">String::String</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cstr = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">    *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">  deleta[] m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串最后有个 \0 占一个字符</li>
<li>有指针就要做动态分配，析构函数释放创建的内存</li>
<li>array new 要搭配 array delete</li>
</ul>
<p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220720000757624.png" alt="image-20220720000757624"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function">String <span class="title">s1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">  String* p = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码段结束时调用了三次析构函数</li>
</ul>
<h4 id="拷贝构造-amp-拷贝赋值"><a href="#拷贝构造-amp-拷贝赋值" class="headerlink" title="拷贝构造 &amp; 拷贝赋值"></a>拷贝构造 &amp; 拷贝赋值</h4><p>class with pointer members 必须有 copy ctor 和 copy op&#x3D;</p>
<p>拷贝构造：分配、拷贝</p>
<p>拷贝赋值：清空、分配、拷贝</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> String&amp; str);</span><br><span class="line">  String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="title">String::String</span><span class="params">(<span class="type">const</span> String&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">delete</span>[] m_data;</span><br><span class="line">  m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝构造函数（深拷贝）：类名&#x3D;函数名&#x3D;参数类型</li>
<li>浅拷贝只拷贝了地址</li>
<li>拷贝赋值要先自我检测</li>
<li>return的是value，至于接受端就看返回类型了</li>
</ul>
<h4 id="output函数"><a href="#output函数" class="headerlink" title="output函数"></a>output函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">  os &lt;&lt; str.<span class="built_in">get_c_str</span>();</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="stack-amp-heap"><a href="#stack-amp-heap" class="headerlink" title="stack &amp; heap"></a>stack &amp; heap</h4><p>stack，存在于某作用域 (scope) 的一块内存空间。当调用函数时，函数本身就会形成一个stack用来放置它所接受的参数，以及返回地址。</p>
<p>heap &#x2F; system heap，指由操作系统提供的一块global内存空间，程序可动态分配 (dynamic allocated) 从某中获得若干区块 (block)。</p>
<p>stack object，在其生命所在作用域结束之际结束生命。称为 auto object，因为它会被自动清理。</p>
<p>static object，作用域结束之后仍然存在，直到整个程序结束。</p>
<p>heap object，其生命在被deleted之后结束。</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>侯捷</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>c++面向对象-4-继承、复合、委托</title>
    <url>/2022/07/23/cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-4/</url>
    <content><![CDATA[<h2 id="Composition复合"><a href="#Composition复合" class="headerlink" title="Composition复合"></a>Composition复合</h2><p>表示 has-a</p>
<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220721235355853.png" alt="image-20220721235355853" style="zoom:50%;" />

<h3 id="设计模式Adapter"><a href="#设计模式Adapter" class="headerlink" title="设计模式Adapter"></a>设计模式Adapter</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  deque&lt;T&gt; c;  <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 以下完全利用 c 的操作函数完成</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复合关系下的构造和析构"><a href="#复合关系下的构造和析构" class="headerlink" title="复合关系下的构造和析构"></a>复合关系下的构造和析构</h3><p>构造由内而外，Container 首先调用 Component 的 default 构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Container::<span class="built_in">Container</span>(...): <span class="built_in">Component</span>() &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>析构由外而内</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Container::~<span class="built_in">Container</span>(...) &#123; ... ~<span class="built_in">Component</span>() &#125;;</span><br></pre></td></tr></table></figure>

<p>由编译器完成</p>
<h2 id="Delegation委托"><a href="#Delegation委托" class="headerlink" title="Delegation委托"></a>Delegation委托</h2><p>Composition by reference</p>
<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220722001117427.png" alt="image-20220722001117427" style="zoom:50%;" />



<h3 id="Handle-x2F-Body-pImpl"><a href="#Handle-x2F-Body-pImpl" class="headerlink" title="Handle &#x2F; Body (pImpl)"></a>Handle &#x2F; Body (pImpl)</h3><p>编译防火墙</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file String.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringRep</span></span><br><span class="line">Class String &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>();</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> cahr* s);</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> String&amp; s);</span><br><span class="line">  String &amp;<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; s);</span><br><span class="line">  ~<span class="built_in">String</span>();</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  StringRep* rep;  <span class="comment">//piml</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file String.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;String.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">StringRep</span> &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">String</span>;</span><br><span class="line">    <span class="built_in">StringRep</span>(<span class="type">const</span> <span class="type">char</span>* s);</span><br><span class="line">    ~<span class="built_in">StringRep</span>();</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">char</span>* rep;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220722000952578.png" alt="image-20220722000952578" style="zoom:50%;" />

<h2 id="Inheritance继承"><a href="#Inheritance继承" class="headerlink" title="Inheritance继承"></a>Inheritance继承</h2><p>表示 is-a</p>
<img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220722003252770.png" alt="image-20220722003252770" style="zoom:50%;" />

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">  _List_node_base* _M_next;</span><br><span class="line">  _List_node_base* _M_prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_List_node</span></span><br><span class="line">  : <span class="keyword">public</span> _List_node_base  <span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line">  _Tp _M_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复合关系下的构造和析构-1"><a href="#复合关系下的构造和析构-1" class="headerlink" title="复合关系下的构造和析构"></a>复合关系下的构造和析构</h3><p>构造由内而外，Container 首先调用 Component 的 default 构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Derived::<span class="built_in">Derived</span>(...): <span class="built_in">Base</span>() &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>析构由外而内</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Derived::~<span class="built_in">Derived</span>(...) &#123; ... ~<span class="built_in">Base</span>() &#125;;</span><br></pre></td></tr></table></figure>

<p>base class的析构函数必须是 virtual，因为是父类或将来可能作为父类</p>
<h3 id="Inheritance-with-virtual-functions-虚函数"><a href="#Inheritance-with-virtual-functions-虚函数" class="headerlink" title="Inheritance with virtual functions(虚函数)"></a>Inheritance with virtual functions(虚函数)</h3><p>non-virtual：你不希望子类重新定义( overwrite )它</p>
<p>virtual：你希望子类重新定义它，且你对它已有默认定义</p>
<p>pure virtual：你希望子类一定要重新定义它，你对它没有默认定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// pure virtual</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;  <span class="comment">//impure virtual</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">objectId</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// non-virtual</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>: <span class="keyword">public</span> Shape &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="设计模式-Template-Method"><a href="#设计模式-Template-Method" class="headerlink" title="设计模式 Template Method"></a>设计模式 Template Method</h3><p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220722005016799.png" alt="image-20220722005016799"></p>
<h2 id="复合-继承"><a href="#复合-继承" class="headerlink" title="复合+继承"></a>复合+继承</h2><p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220722005806700.png" alt="image-20220722005806700"></p>
<p>子类里有复合：</p>
<p>构造顺序：Base -&gt; Component -&gt; Derived</p>
<p>析构顺序：Derived -&gt; Component -&gt; Base</p>
<h2 id="委托-继承"><a href="#委托-继承" class="headerlink" title="委托+继承"></a>委托+继承</h2><p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220722010424682.png" alt="image-20220722010424682"></p>
<p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220723000101126.png" alt="image-20220723000101126"></p>
<p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220723002528349.png" alt="image-20220723002528349"></p>
<p>推荐阅读：《Desgin Patterns Explained Simply》</p>
<p>《C++ prime》</p>
<p>《Effective Modern C++》</p>
<p>《STL源码剖析》</p>
]]></content>
      <tags>
        <tag>侯捷</tag>
        <tag>OOP</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模基础知识</title>
    <url>/2022/10/04/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>c++面向对象-3-static、template、namespace</title>
    <url>/2022/07/22/cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-3/</url>
    <content><![CDATA[<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220720235234099.png" alt="image-20220720235234099"></p>
<ul>
<li><p>成员函数依靠 this point 传递数据</p>
</li>
<li><p>黄色部分可写可不写</p>
</li>
</ul>
<p>静态数据使用场景：银行用户类里的利率</p>
<p>静态函数使用场景：处理静态数据（没有 this point）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">double</span> m_rate;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_rate</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x)</span> </span>&#123; x_rate = x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">double</span> Account::m_rate = <span class="number">8.0</span>;  <span class="comment">// 定义(可以不赋初值)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用1</span></span><br><span class="line">  Account::<span class="built_in">set_rate</span>(<span class="number">5.0</span>);</span><br><span class="line">  <span class="comment">// 调用2</span></span><br><span class="line">  Account a;</span><br><span class="line">  a.<span class="built_in">set_rate</span>(<span class="number">7.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单体设计模式-Singleton"><a href="#单体设计模式-Singleton" class="headerlink" title="单体设计模式 Singleton"></a>单体设计模式 Singleton</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">( <span class="keyword">return</span> a; )</span></span>;</span><br><span class="line">  <span class="built_in">setup</span>() &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">A</span>();</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">  <span class="type">static</span> A a;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外界只能通过 <code>A::getInstance().setup();</code> 调用</p>
<h3 id="Meryers-Singleton"><a href="#Meryers-Singleton" class="headerlink" title="Meryers Singleton"></a>Meryers Singleton</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="built_in">setup</span>() &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">A</span>();</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> A a;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>getInstance()</code> 以后才会创建 a</p>
<h2 id="class-template"><a href="#class-template" class="headerlink" title="class template"></a>class template</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">complex</span> (T r = <span class="number">0</span>, T i = <span class="number">0</span>)</span><br><span class="line">    : <span class="built_in">re</span> (r), <span class="built_in">im</span> (i)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex&amp;) ;</span><br><span class="line">  <span class="function">T <span class="title">real</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">  <span class="function">T <span class="title">imag</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T re, im;</span><br><span class="line">  <span class="keyword">friend</span> complex&amp; __doapl (complex*, <span class="type">const</span> conplex&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">2.5</span>,<span class="number">1.5</span>)</span></span>;</span><br><span class="line">  <span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">2</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="function-template"><a href="#function-template" class="headerlink" title="function template"></a>function template</h2> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b &lt; a ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">stone <span class="title">r1</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span>, <span class="title">r2</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span>, r3</span>;</span><br><span class="line">r3 = <span class="built_in">min</span>(r1, r2);</span><br></pre></td></tr></table></figure>

<p>编译器会对 function template 进行 引数推导 (arguement deduction)</p>
<p>引数推导的结果，T为stone，于是调用 stone::operator &lt;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">stone</span>(<span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> we)</span><br><span class="line">    : _w(w), _h(h), _weight(we)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> stone&amp; rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> _weight &lt; rhs._weight; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> _w, _h, _weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有内容被包装到 std 的命名空间里</p>
<ul>
<li>std 可以分段写</li>
</ul>
<h3 id="using-directive"><a href="#using-directive" class="headerlink" title="using directive"></a>using directive</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cin&gt;&gt;...;</span><br><span class="line">  cout&lt;&lt;...;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="using-declaretion"><a href="#using-declaretion" class="headerlink" title="using declaretion"></a>using declaretion</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cin&gt;&gt;...;</span><br><span class="line">  cout&lt;&lt;...;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><img src="https://picb.oss-cn-beijing.aliyuncs.com/img/image-20220721003056490.png" alt="image-20220721003056490"></p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>侯捷</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
</search>
